#ifndef SCARABEE_MATH_H
#define SCARABEE_MATH_H

namespace scarabee {

double exp(double x);

// Evaluates 1 - exp(-x)
inline double mexp(double x) {
  // This function was taken from OpenMOC : expF1_fractional
  // Originally generated by Colin Josey with Remez's algorithm.

  // Coefficients for numerator
  constexpr double p0 = 1.0;
  constexpr double p1 = 2.4172687328033081 * 1E-1;
  constexpr double p2 = 6.2804790965268531 * 1E-2;
  constexpr double p3 = 1.0567595009016521 * 1E-2;
  constexpr double p4 = 1.0059468082903561 * 1E-3;
  constexpr double p5 = 1.9309063097411041 * 1E-4;

  // Coefficients for denominator
  constexpr double d0 = 1.0;
  constexpr double d1 = 7.4169266112320541 * 1E-1;
  constexpr double d2 = 2.6722515319494311 * 1E-1;
  constexpr double d3 = 6.1643725066901411 * 1E-2;
  constexpr double d4 = 1.0590759992367811 * 1E-2;
  constexpr double d5 = 1.0057980007137651 * 1E-3;
  constexpr double d6 = 1.9309063097411041 * 1E-4;

  double num, den;

  den = d6 * x + d5;
  den = den * x + d4;
  den = den * x + d3;
  den = den * x + d2;
  den = den * x + d1;
  den = den * x + d0;
  den = 1.f / den;

  num = p5 * x + p4;
  num = num * x + p3;
  num = num * x + p2;
  num = num * x + p1;
  num = num * x + p0;

  return x * num * den;
}

double Ki3(double x);
double Ki3_quad(double x);

double legendre(const unsigned int& order, const double& x);
double derivative_legendre(const unsigned int& order, const unsigned int& n,
                           const double& x);
double assoc_legendre(const unsigned int& order, const int& j, const double& x);

// // spherical harmonics
// // phi: azimuthal angle and theta: polar angle
double spherical_hamonics(const unsigned int& l, const int& j,
                          const double& phi, const double& theta);

inline double factorial(const unsigned int& N) {
  double value = 1.;
  for (unsigned int i = 1; i <= N; i++) {
    value *= static_cast<double>(i);
  }
  return value;
}

}  // namespace scarabee

#endif
